use memecoin_staking::errors::Error;
use memecoin_staking::memecoin_staking::interface::{
    IMemeCoinStakingConfigDispatcher, IMemeCoinStakingConfigDispatcherTrait,
    IMemeCoinStakingDispatcher, IMemeCoinStakingDispatcherTrait, IMemeCoinStakingSafeDispatcher,
    IMemeCoinStakingSafeDispatcherTrait, StakeDuration, StakeDurationTrait,
};
use memecoin_staking::test_utils::{
<<<<<<< HEAD
    TestCfg, advance_time, approve_and_fund, approve_and_stake, calculate_points,
    cheat_staker_approve_staking, deploy_memecoin_staking_contract, load_and_verify_value,
    load_value, memecoin_staking_test_setup, verify_stake_info,
||||||| parent of 690ca00 (feat(staking): add unstake function)
    STAKER_SUPPLY, TestCfg, advance_time, approve_and_fund, approve_and_stake, calculate_points,
    cheat_staker_approve_staking, deploy_memecoin_staking_contract, load_and_verify_value,
    load_value, memecoin_staking_test_setup, verify_stake_info,
=======
    STAKER_SUPPLY, TestCfg, advance_time, approve_and_fund, approve_and_stake, calculate_points,
    cheat_caller_address_many, cheat_staker_approve_staking, deploy_memecoin_staking_contract,
    load_and_verify_value, load_value, memecoin_staking_test_setup, verify_stake_info,
>>>>>>> 690ca00 (feat(staking): add unstake function)
};
use memecoin_staking::types::{Amount, Cycle, Index};
use openzeppelin::token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
use starknet::ContractAddress;
use starkware_utils::errors::Describable;
use starkware_utils_testing::test_utils::{assert_panic_with_error, cheat_caller_address_once};

#[test]
fn test_constructor() {
    let mut cfg: TestCfg = Default::default();
    deploy_memecoin_staking_contract(ref :cfg);

    load_and_verify_value(
        contract_address: cfg.staking_contract,
        storage_address: selector!("owner"),
        expected_value: cfg.owner,
    );

    let loaded_token_dispatcher = load_value::<
        IERC20Dispatcher,
    >(contract_address: cfg.staking_contract, storage_address: selector!("token_dispatcher"));
    assert!(loaded_token_dispatcher.contract_address == cfg.token_address);

    load_and_verify_value(
        contract_address: cfg.staking_contract,
        storage_address: selector!("current_reward_cycle"),
        expected_value: 0,
    );

    load_and_verify_value(
        contract_address: cfg.staking_contract,
        storage_address: selector!("total_points_for_current_reward_cycle"),
        expected_value: 0,
    );
}

#[test]
fn test_set_rewards_contract() {
    let mut cfg: TestCfg = Default::default();
    deploy_memecoin_staking_contract(ref :cfg);
    let rewards_contract = cfg.rewards_contract;
    let dispatcher = IMemeCoinStakingConfigDispatcher { contract_address: cfg.staking_contract };

    cheat_caller_address_once(contract_address: cfg.staking_contract, caller_address: cfg.owner);
    dispatcher.set_rewards_contract(:rewards_contract);

    load_and_verify_value(
        contract_address: cfg.staking_contract,
        storage_address: selector!("rewards_contract"),
        expected_value: rewards_contract,
    );
}

#[test]
#[should_panic(expected: "Can only be called by the owner")]
fn test_set_rewards_contract_wrong_caller() {
    let mut cfg: TestCfg = Default::default();
    deploy_memecoin_staking_contract(ref :cfg);
    let rewards_contract = cfg.rewards_contract;
    let dispatcher = IMemeCoinStakingConfigDispatcher { contract_address: cfg.staking_contract };

    dispatcher.set_rewards_contract(:rewards_contract);
}

#[test]
fn test_stake() {
    let cfg = memecoin_staking_test_setup();
    let staking_dispatcher = IMemeCoinStakingDispatcher { contract_address: cfg.staking_contract };
    let mut total_points: u128 = 0;

    let amount: Amount = cfg.staker_supply / 3;
    let stake_duration = StakeDuration::OneMonth;
    total_points += calculate_points(:amount, :stake_duration);
    cheat_staker_approve_staking(:cfg, :amount);
    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: cfg.staker_address,
    );
    let stake_index = staking_dispatcher.stake(:amount, :stake_duration);
    assert!(stake_index == 0);

    let stake_duration = StakeDuration::ThreeMonths;
    cheat_staker_approve_staking(:cfg, :amount);
    total_points += calculate_points(:amount, :stake_duration);
    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: cfg.staker_address,
    );
    let stake_index = staking_dispatcher.stake(:amount, :stake_duration);
    assert!(stake_index == 0);

    let stake_duration = StakeDuration::OneMonth;
    cheat_staker_approve_staking(:cfg, :amount);
    total_points += calculate_points(:amount, :stake_duration);
    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: cfg.staker_address,
    );
    let stake_index = staking_dispatcher.stake(:amount, :stake_duration);
    assert!(stake_index == 1);

    load_and_verify_value(
        contract_address: cfg.staking_contract,
        storage_address: selector!("current_reward_cycle"),
        expected_value: 0,
    );

    load_and_verify_value(
        contract_address: cfg.staking_contract,
        storage_address: selector!("total_points_for_current_reward_cycle"),
        expected_value: total_points,
    );
}

#[test]
fn test_get_stake_info_same_duration() {
    // Setup.
    let cfg = memecoin_staking_test_setup();
    let staker_address = cfg.staker_address;
    let mut staker_balance: Amount = cfg.staker_supply;
    let staking_dispatcher = IMemeCoinStakingDispatcher { contract_address: cfg.staking_contract };

    // Stake 10 times with different amounts.
    let stake_duration = StakeDuration::SixMonths;
    let mut stake_indexes = array![];
    let mut stake_amounts = array![];
    for _ in 0..10_u32 {
        let amount = staker_balance / 3;
        staker_balance -= amount;
        let stake_index = approve_and_stake(:cfg, :staker_address, :amount, :stake_duration);
        stake_amounts.append(value: amount);
        stake_indexes.append(value: stake_index);
    }

    // Verify the stake info for each stake.
    for i in 0..10_u32 {
        let stake_index = *stake_indexes.at(index: i);
        let amount = *stake_amounts.at(index: i);
        let stake_info = staking_dispatcher
            .get_stake_info(:staker_address, :stake_duration, :stake_index)
            .unwrap();
        verify_stake_info(:stake_info, reward_cycle: 0, :amount, :stake_duration, claimed: false);
    }
}

#[test]
fn test_get_stake_info_different_durations() {
    // Setup.
    let cfg = memecoin_staking_test_setup();
    let staker_address = cfg.staker_address;
    let mut staker_balance: Amount = cfg.staker_supply;
    let staking_dispatcher = IMemeCoinStakingDispatcher { contract_address: cfg.staking_contract };

    // Stake 10 times with different amounts.
    let stake_durations = array![
        StakeDuration::OneMonth,
        StakeDuration::ThreeMonths,
        StakeDuration::OneMonth,
        StakeDuration::TwelveMonths,
        StakeDuration::SixMonths,
        StakeDuration::TwelveMonths,
        StakeDuration::SixMonths,
        StakeDuration::ThreeMonths,
        StakeDuration::ThreeMonths,
        StakeDuration::SixMonths,
    ];
    let mut stake_amounts = array![];
    let mut stake_indexes = array![];
    for i in 0..10_u32 {
        let amount = staker_balance / 2;
        staker_balance -= amount;
        let stake_duration = *stake_durations.at(index: i);
        let stake_index = approve_and_stake(:cfg, :staker_address, :amount, :stake_duration);
        stake_amounts.append(value: amount);
        stake_indexes.append(value: stake_index);
    }

    // Verify the stake info for each stake.
    for i in 0..10_u32 {
        let stake_index = *stake_indexes.at(index: i);
        let amount = *stake_amounts.at(index: i);
        let stake_duration = *stake_durations.at(index: i);
        let stake_info = staking_dispatcher
            .get_stake_info(:staker_address, :stake_duration, :stake_index)
            .unwrap();
        verify_stake_info(:stake_info, reward_cycle: 0, :amount, :stake_duration, claimed: false);
    }
}

#[test]
fn test_get_stake_info_not_exist() {
    // Setup.
    let cfg = memecoin_staking_test_setup();
    let staker_address = cfg.staker_address;
    let mut staker_balance: Amount = cfg.staker_supply;
    let staking_dispatcher = IMemeCoinStakingDispatcher { contract_address: cfg.staking_contract };

    // Verify that the stake info does not exist before staking.
    let stake_info = staking_dispatcher
        .get_stake_info(:staker_address, stake_duration: StakeDuration::OneMonth, stake_index: 0);
    assert!(stake_info.is_none());

    // Stake and verify existence.
    let amount: Amount = staker_balance;
    let stake_duration = StakeDuration::OneMonth;
    let stake_index = approve_and_stake(:cfg, :staker_address, :amount, :stake_duration);
    let stake_info = staking_dispatcher
        .get_stake_info(:staker_address, :stake_duration, :stake_index);
    assert!(stake_info.is_some());

    // Verify that the stake info does not exist for future index.
    let stake_info = staking_dispatcher
        .get_stake_info(:staker_address, stake_duration: StakeDuration::OneMonth, stake_index: 1);
    assert!(stake_info.is_none());

    // Verify that the stake info does not exist for other stake durations.
    let stake_durations = array![
        StakeDuration::ThreeMonths, StakeDuration::SixMonths, StakeDuration::TwelveMonths,
    ];
    for i in 0..stake_durations.len() {
        let stake_duration = *stake_durations.at(index: i);
        let stake_info = staking_dispatcher
            .get_stake_info(:staker_address, :stake_duration, stake_index: 0);
        assert!(stake_info.is_none());

        let stake_info = staking_dispatcher
            .get_stake_info(:staker_address, :stake_duration, stake_index: 1);
        assert!(stake_info.is_none());
    }
}

#[test]
#[should_panic(expected: 'ERC20: insufficient allowance')]
fn test_stake_without_approve() {
    let cfg = memecoin_staking_test_setup();
    let staking_dispatcher = IMemeCoinStakingDispatcher { contract_address: cfg.staking_contract };

    let amount: Amount = 1000;
    let stake_duration = StakeDuration::OneMonth;
    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: cfg.staker_address,
    );
    staking_dispatcher.stake(:amount, :stake_duration);
}

#[test]
#[should_panic(expected: 'ERC20: insufficient balance')]
fn test_stake_insufficient_balance() {
    let cfg = memecoin_staking_test_setup();
    let staking_dispatcher = IMemeCoinStakingDispatcher { contract_address: cfg.staking_contract };

    let amount: Amount = cfg.staker_supply + 1;
    let stake_duration = StakeDuration::OneMonth;
    cheat_staker_approve_staking(:cfg, :amount);
    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: cfg.staker_address,
    );
    staking_dispatcher.stake(:amount, :stake_duration);
}

#[test]
#[should_panic(expected: "Can't close reward cycle with no stakes")]
fn test_close_reward_cycle_no_stakes() {
    let cfg = memecoin_staking_test_setup();
    let staking_dispatcher = IMemeCoinStakingDispatcher { contract_address: cfg.staking_contract };

    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: cfg.rewards_contract,
    );
    staking_dispatcher.close_reward_cycle();
}

#[test]
#[should_panic(expected: "Can only be called by the rewards contract")]
fn test_close_reward_cycle_wrong_caller() {
    let cfg = memecoin_staking_test_setup();
    let staking_dispatcher = IMemeCoinStakingDispatcher { contract_address: cfg.staking_contract };

    staking_dispatcher.close_reward_cycle();
}

#[test]
fn test_close_reward_cycle() {
    // Setup.
    let cfg = memecoin_staking_test_setup();
    let staker_address = cfg.staker_address;
    let staking_dispatcher = IMemeCoinStakingDispatcher { contract_address: cfg.staking_contract };
    let mut stake_indexes: Array<Index> = array![];
    let stake_duration = StakeDuration::OneMonth;
    let mut reward_cycle = 0;

    // First stake.
    let amount: Amount = cfg.staker_supply / 2;
    let stake_index = approve_and_stake(:cfg, :staker_address, :amount, :stake_duration);
    stake_indexes.append(value: stake_index);

    // Close the first reward cycle and verify the total points.
    load_and_verify_value(
        contract_address: cfg.staking_contract,
        storage_address: selector!("total_points_for_current_reward_cycle"),
        expected_value: calculate_points(:amount, :stake_duration),
    );
    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: cfg.rewards_contract,
    );
    let total_points = staking_dispatcher.close_reward_cycle();
    reward_cycle += 1;
    assert!(total_points == calculate_points(:amount, :stake_duration));
    load_and_verify_value(
        contract_address: cfg.staking_contract,
        storage_address: selector!("current_reward_cycle"),
        expected_value: reward_cycle,
    );
    load_and_verify_value(
        contract_address: cfg.staking_contract,
        storage_address: selector!("total_points_for_current_reward_cycle"),
        expected_value: 0,
    );

    // Second stake.
    let stake_index = approve_and_stake(:cfg, :staker_address, :amount, :stake_duration);
    stake_indexes.append(value: stake_index);

    // Close the second reward cycle and verify the total points.
    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: cfg.rewards_contract,
    );
    let total_points = staking_dispatcher.close_reward_cycle();
    reward_cycle += 1;
    assert!(total_points == calculate_points(:amount, :stake_duration));
    load_and_verify_value(
        contract_address: cfg.staking_contract,
        storage_address: selector!("current_reward_cycle"),
        expected_value: reward_cycle,
    );
    load_and_verify_value(
        contract_address: cfg.staking_contract,
        storage_address: selector!("total_points_for_current_reward_cycle"),
        expected_value: 0,
    );

    // Verify stake info for each stake.
    for i in 0..stake_indexes.len() {
        let stake_index: Index = *stake_indexes.at(index: i);
        let reward_cycle: Cycle = i.into();
        let stake_info = staking_dispatcher
            .get_stake_info(:staker_address, :stake_duration, :stake_index)
            .unwrap();
        verify_stake_info(:stake_info, :reward_cycle, :amount, :stake_duration, claimed: false);
    }
}

#[test]
#[feature("safe_dispatcher")]
fn test_claim_rewards_sanity() {
    // Setup.
    let cfg = memecoin_staking_test_setup();
    let staker_address = cfg.staker_address;
    let token_dispatcher = IERC20Dispatcher { contract_address: cfg.token_address };
    let staking_dispatcher = IMemeCoinStakingDispatcher { contract_address: cfg.staking_contract };
    let staking_safe_dispatcher = IMemeCoinStakingSafeDispatcher {
        contract_address: cfg.staking_contract,
    };

    // Stake and fund.
    let amount: Amount = STAKER_SUPPLY;
    let stake_duration = StakeDuration::OneMonth;
    let stake_index = approve_and_stake(:cfg, :staker_address, :amount, :stake_duration);

    let fund_amount = 1000;
    approve_and_fund(:cfg, :fund_amount);

    // Claim rewards before vesting time.
    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: cfg.staker_address,
    );
    let res = staking_safe_dispatcher.claim_rewards(:stake_duration, :stake_index);
    assert_panic_with_error(res, Error::STAKE_NOT_VESTED.describe());

    // Claim rewards after vesting time.
    advance_time(time_delta: stake_duration.to_time_delta().unwrap());
    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: cfg.staker_address,
    );
    let rewards = staking_dispatcher.claim_rewards(:stake_duration, :stake_index);
    assert!(rewards == fund_amount);
    let staker_balance = token_dispatcher.balance_of(account: staker_address);
    assert!(staker_balance == fund_amount.into());

    // Claim rewards again.
    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: cfg.staker_address,
    );
    let res = staking_safe_dispatcher.claim_rewards(:stake_duration, :stake_index);
    assert_panic_with_error(res, Error::STAKE_ALREADY_CLAIMED.describe());
}

#[test]
#[should_panic(expected: "Stake not found")]
fn test_claim_rewards_not_found() {
    let cfg = memecoin_staking_test_setup();
    let staking_dispatcher = IMemeCoinStakingDispatcher { contract_address: cfg.staking_contract };

    let stake_duration = StakeDuration::OneMonth;
    let stake_index = 0;

    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: cfg.staker_address,
    );
    staking_dispatcher.claim_rewards(:stake_duration, :stake_index);
}

#[test]
#[should_panic(expected: "Rewards contract not set")]
fn test_claim_rewards_rewards_contract_not_set() {
    let mut cfg: TestCfg = Default::default();
    deploy_memecoin_staking_contract(ref :cfg);
    let staking_dispatcher = IMemeCoinStakingDispatcher { contract_address: cfg.staking_contract };

    let stake_duration = StakeDuration::OneMonth;
    let stake_index = 0;

    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: cfg.staker_address,
    );
    staking_dispatcher.claim_rewards(:stake_duration, :stake_index);
}

fn unstake_test_setup() -> (
    TestCfg, ContractAddress, IMemeCoinStakingDispatcher, IERC20Dispatcher,
) {
    let cfg = memecoin_staking_test_setup();
    let staker_address = cfg.staker_address;
    let staking_dispatcher = IMemeCoinStakingDispatcher { contract_address: cfg.staking_contract };
    let token_dispatcher = IERC20Dispatcher { contract_address: cfg.token_address };

    (cfg, staker_address, staking_dispatcher, token_dispatcher)
}

#[test]
fn test_unstake_current_cycle_stake() {
    let (cfg, staker_address, staking_dispatcher, token_dispatcher) = unstake_test_setup();

    let amount: Amount = STAKER_SUPPLY;
    let stake_duration = StakeDuration::OneMonth;
    let stake_index = approve_and_stake(:cfg, :staker_address, :amount, :stake_duration);

    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: staker_address,
    );
    staking_dispatcher.unstake(:stake_duration, :stake_index);
    let staker_balance = token_dispatcher.balance_of(account: staker_address);
    assert!(staker_balance == amount.into());
    let staking_contract_balance = token_dispatcher.balance_of(account: cfg.staking_contract);
    assert!(staking_contract_balance == 0);
}

#[test]
fn test_unstake_unvested_stake() {
    let (cfg, staker_address, staking_dispatcher, token_dispatcher) = unstake_test_setup();

    let amount: Amount = STAKER_SUPPLY;
    let stake_duration = StakeDuration::OneMonth;
    let stake_index = approve_and_stake(:cfg, :staker_address, :amount, :stake_duration);

    let fund_amount = 1000;
    approve_and_fund(:cfg, :fund_amount);

    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: staker_address,
    );
    staking_dispatcher.unstake(:stake_duration, :stake_index);
    let staker_balance = token_dispatcher.balance_of(account: staker_address);
    assert!(staker_balance == amount.into());
    let staking_contract_balance = token_dispatcher.balance_of(account: cfg.staking_contract);
    assert!(staking_contract_balance == 0);
    let rewards_contract_balance = token_dispatcher.balance_of(account: cfg.rewards_contract);
    assert!(rewards_contract_balance == fund_amount.into());
}

#[test]
fn test_unstake_unclaimed_stake() {
    let (cfg, staker_address, staking_dispatcher, token_dispatcher) = unstake_test_setup();

    let amount: Amount = STAKER_SUPPLY;
    let stake_duration = StakeDuration::OneMonth;
    let stake_index = approve_and_stake(:cfg, :staker_address, :amount, :stake_duration);

    let fund_amount = 1000;
    approve_and_fund(:cfg, :fund_amount);
    advance_time(time_delta: stake_duration.to_time_delta().unwrap());

    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: staker_address,
    );
    staking_dispatcher.unstake(:stake_duration, :stake_index);
    let staker_balance = token_dispatcher.balance_of(account: staker_address);
    assert!(staker_balance == amount.into() + fund_amount.into());
    let staking_contract_balance = token_dispatcher.balance_of(account: cfg.staking_contract);
    assert!(staking_contract_balance == 0);
    let rewards_contract_balance = token_dispatcher.balance_of(account: cfg.rewards_contract);
    assert!(rewards_contract_balance == 0);
}

#[test]
fn test_unstake_claimed_stake() {
    let (cfg, staker_address, staking_dispatcher, token_dispatcher) = unstake_test_setup();

    let amount: Amount = STAKER_SUPPLY;
    let stake_duration = StakeDuration::OneMonth;
    let stake_index = approve_and_stake(:cfg, :staker_address, :amount, :stake_duration);

    let fund_amount = 1000;
    approve_and_fund(:cfg, :fund_amount);
    advance_time(time_delta: stake_duration.to_time_delta().unwrap());
    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: staker_address,
    );
    staking_dispatcher.claim_rewards(:stake_duration, :stake_index);

    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: staker_address,
    );
    staking_dispatcher.unstake(:stake_duration, :stake_index);
    let staker_balance = token_dispatcher.balance_of(account: staker_address);
    assert!(staker_balance == amount.into() + fund_amount.into());
    let staking_contract_balance = token_dispatcher.balance_of(account: cfg.staking_contract);
    assert!(staking_contract_balance == 0);
    let rewards_contract_balance = token_dispatcher.balance_of(account: cfg.rewards_contract);
    assert!(rewards_contract_balance == 0);
}

#[test]
#[should_panic(expected: "Stake already unstaked")]
fn test_unstake_twice() {
    let (cfg, staker_address, staking_dispatcher, _) = unstake_test_setup();

    let amount: Amount = STAKER_SUPPLY;
    let stake_duration = StakeDuration::OneMonth;
    let stake_index = approve_and_stake(:cfg, :staker_address, :amount, :stake_duration);

    cheat_caller_address_many(
        contract_address: cfg.staking_contract, caller_address: staker_address, num_calls: 2,
    );
    staking_dispatcher.unstake(:stake_duration, :stake_index);
    staking_dispatcher.unstake(:stake_duration, :stake_index);
}

#[test]
#[feature("safe_dispatcher")]
fn test_unstake_all_scenarios() {
    // Setup.
    let cfg = memecoin_staking_test_setup();
    let staker_address = cfg.staker_address;
    let staking_dispatcher = IMemeCoinStakingDispatcher { contract_address: cfg.staking_contract };
    let staking_safe_dispatcher = IMemeCoinStakingSafeDispatcher {
        contract_address: cfg.staking_contract,
    };
    let token_dispatcher = IERC20Dispatcher { contract_address: cfg.token_address };
    let mut total_points: u128 = 0;

    // Stake.
    let amount: Amount = STAKER_SUPPLY / 4;
    let stake_duration = StakeDuration::ThreeMonths;
    let unvested_stake_index = approve_and_stake(:cfg, :staker_address, :amount, :stake_duration);
    total_points += calculate_points(:amount, :stake_duration);

    let stake_duration = StakeDuration::OneMonth;
    let unclaimed_stake_index = approve_and_stake(:cfg, :staker_address, :amount, :stake_duration);
    total_points += calculate_points(:amount, :stake_duration);

    let claimed_stake_index = approve_and_stake(:cfg, :staker_address, :amount, :stake_duration);
    total_points += calculate_points(:amount, :stake_duration);

    let fund_amount = 1000;
    approve_and_fund(:cfg, :fund_amount);

    let current_cycle_stake_index = approve_and_stake(
        :cfg, :staker_address, :amount, :stake_duration,
    );

    // Adjust stake states.
    advance_time(time_delta: stake_duration.to_time_delta().unwrap());
    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: staker_address,
    );
    let rewards = staking_dispatcher
        .claim_rewards(:stake_duration, stake_index: claimed_stake_index);

    let mut expected_staker_balance = rewards;
    let mut expected_staking_contract_balance = amount * 4;
    let mut expected_rewards_contract_balance = fund_amount - rewards;

    // Current cycle stake.
    let stake_duration = StakeDuration::OneMonth;
    let stake_index = current_cycle_stake_index;
    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: staker_address,
    );
    staking_dispatcher.unstake(:stake_duration, :stake_index);
    expected_staker_balance += amount;
    expected_staking_contract_balance -= amount;
    load_and_verify_value(
        contract_address: cfg.staking_contract,
        storage_address: selector!("total_points_for_current_reward_cycle"),
        expected_value: 0,
    );

    let staker_balance = token_dispatcher.balance_of(account: staker_address);
    let staking_contract_balance = token_dispatcher.balance_of(account: cfg.staking_contract);
    let rewards_contract_balance = token_dispatcher.balance_of(account: cfg.rewards_contract);

    assert!(staker_balance == expected_staker_balance.into());
    assert!(staking_contract_balance == expected_staking_contract_balance.into());
    assert!(rewards_contract_balance == expected_rewards_contract_balance.into());

    // Unvested stake.
    let stake_duration = StakeDuration::ThreeMonths;
    let stake_index = unvested_stake_index;
    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: staker_address,
    );
    staking_dispatcher.unstake(:stake_duration, :stake_index);
    expected_staker_balance += amount;
    expected_staking_contract_balance -= amount;

    let staker_balance = token_dispatcher.balance_of(account: staker_address);
    let staking_contract_balance = token_dispatcher.balance_of(account: cfg.staking_contract);
    let rewards_contract_balance = token_dispatcher.balance_of(account: cfg.rewards_contract);

    assert!(staker_balance == expected_staker_balance.into());
    assert!(staking_contract_balance == expected_staking_contract_balance.into());
    assert!(rewards_contract_balance == expected_rewards_contract_balance.into());

    // Unclaimed stake.
    let stake_duration = StakeDuration::OneMonth;
    let stake_index = unclaimed_stake_index;
    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: staker_address,
    );
    staking_dispatcher.unstake(:stake_duration, :stake_index);
    expected_staker_balance += amount + expected_rewards_contract_balance;
    expected_staking_contract_balance -= amount;
    expected_rewards_contract_balance = 0;

    let staker_balance = token_dispatcher.balance_of(account: staker_address);
    let staking_contract_balance = token_dispatcher.balance_of(account: cfg.staking_contract);
    let rewards_contract_balance = token_dispatcher.balance_of(account: cfg.rewards_contract);

    assert!(staker_balance == expected_staker_balance.into());
    assert!(staking_contract_balance == expected_staking_contract_balance.into());
    assert!(rewards_contract_balance == expected_rewards_contract_balance.into());

    // Claimed stake.
    let stake_duration = StakeDuration::OneMonth;
    let stake_index = claimed_stake_index;
    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: staker_address,
    );
    staking_dispatcher.unstake(:stake_duration, :stake_index);
    expected_staker_balance += amount;
    expected_staking_contract_balance -= amount;

    let staker_balance = token_dispatcher.balance_of(account: staker_address);
    let staking_contract_balance = token_dispatcher.balance_of(account: cfg.staking_contract);
    let rewards_contract_balance = token_dispatcher.balance_of(account: cfg.rewards_contract);

    assert!(staker_balance == expected_staker_balance.into());
    assert!(staking_contract_balance == expected_staking_contract_balance.into());
    assert!(rewards_contract_balance == expected_rewards_contract_balance.into());

    // Unstake again.
    cheat_caller_address_once(
        contract_address: cfg.staking_contract, caller_address: staker_address,
    );
    let res = staking_safe_dispatcher.unstake(:stake_duration, stake_index: claimed_stake_index);
    assert_panic_with_error(res, Error::STAKE_ALREADY_UNSTAKED.describe());
}
